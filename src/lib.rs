use std::fmt::{Debug, Formatter, LowerHex, Result};
use std::ops::Div;

use num_bigint::BigUint;
use num_traits::Num;

#[derive(PartialEq)]
struct Endian(BigUint);

impl Debug for Endian {
    fn fmt(&self, f: &mut Formatter) -> Result {
        write!(f, "{}", self.0)
    }
}

impl From<Hex> for Endian {
    fn from(hex: Hex) -> Self {
        Endian(BigUint::from_str_radix(hex.0.trim_start_matches("0x"), 16).unwrap())
    }
}

impl LowerHex for Endian {
    fn fmt(&self, f: &mut Formatter) -> Result {
        f.pad_integral(true, "0x", &self.0.to_str_radix(16))
    }
}

impl Endian {
    pub fn new(num: u128) -> Self {
        Endian(BigUint::from(num))
    }

    pub fn into_hex(self) -> Hex {
        Hex::from(self)
    }
}

#[derive(PartialEq)]
struct Hex(String);

impl Debug for Hex {
    fn fmt(&self, f: &mut Formatter) -> Result {
        write!(f, "{}", self.0)
    }
}

impl From<Endian> for Hex {
    fn from(endian: Endian) -> Self {
        Hex(format!("0x{:x}", endian))
    }
}

impl Hex {
    pub fn new(src: &str) -> Self {
        Hex(src.to_string())
    }

    pub fn bytes(&self) -> u32 {
        self.0
            .trim_start_matches("0x")
            .len()
            .div(2)
            .try_into()
            .unwrap()
    }

    pub fn little_endian(&self) -> Endian {
        let mut hash = self.0.clone().trim_start_matches("0x").to_string();
        while hash.ends_with("0") {
            hash.pop();
        }

        if hash.len() % 2 != 0 {
            hash.push('0');
        }

        Endian(BigUint::from_str_radix(hash.as_str(), 16).unwrap())
    }

    pub fn big_endian(&self) -> Endian {
        Endian(BigUint::from_str_radix(self.0.trim_start_matches("0x"), 16).unwrap())
    }
}

#[cfg(test)]
mod tests {
    use crate::Endian;
    use crate::Hex;

    #[test]
    fn hex_to_endian() {
        let value = Hex::new("0xff00000000000000000000000000000000000000000000000000000000000000");
        // Number of bytes: 32
        assert_eq!(32_u32, value.bytes());
        // Little-endian: 255
        assert_eq!(Endian::new(255), value.little_endian());
    }

    #[test]
    fn hex_to_big_endian() {
        let value = Hex::new("0xaaaa000000000000000000000000000000000000000000000000000000000000");
        // Big-endian: 77193548260167611359494267807458109956502771454495792280332974934474558013440
        assert_eq!(
            "77193548260167611359494267807458109956502771454495792280332974934474558013440"
                .to_string(),
            format!("{:?}", value.big_endian())
        );
    }

    #[test]
    fn little_endian_to_hex() {
        let value = Endian::new(4294967295);
        assert_eq!(Hex::new("0xffffffff"), value.into_hex());
    }

    #[test]
    fn big_endian_to_hex() {
        let value = Endian::new(5192296858459269764804582005800960);
        assert_eq!(Hex::new("0xfffffffff0000000000000000000"), value.into_hex());
    }

    #[test]
    fn test_vector_4() {
        let value = Hex::new("0xF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
        assert_eq!(512, value.bytes());
        assert_eq!(Endian::new(240), value.little_endian());
        assert_eq!(
            "979114576324830475023518166296835358668716483481922294110218890578706788723335115795775136189060210944584475044786808910613350098299181506809283832360654948074334665509728123444088990750984735919776315636114949587227798911935355699067813766573049953903257414411690972566828795693861196044813729172123152193769005290826676049325224028303369631812105737593272002471587527915367835952474124875982077070337970837392460768423348044782340688207323630599527945406427226264695390995320400314062984891593411332752703846859640346323687201762934524222363836094053204269986087043470117703336873406636573235808683444836432453459818599293667760149123595668832133083221407128310342064668595954073131257995767262426534143159642539179485013975461689493733866106312135829807129162654188209922755829012304582671671519678313609748646814745057724363462189490278183457296449014163077506949636570237334109910914728582640301294341605533983878368789071427913184794906223657920124153256147359625549743656058746335124502376663710766611046750739680547042183503568549468592703882095207981161012224965829605768300297615939788368703353944514111011011184191740295491255291545096680705534063721012625490368756140460791685877738232879406346334603566914069127957053440".to_string(),
            format!("{:?}", value.big_endian())
        );
    }
}
